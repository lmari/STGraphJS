<html>
<head>
</head>
<body>
<h1>Prova</h1>
<script>
'use strict';
function Token(type, value) {
	this.type = type;
	this.value = value;
}

let _max = (x,y) => Math.max(x,y);

let isDot = ch => ch == '.'; let isComma = ch => ch == ',';
let isLeftPar = ch => ch == '('; let isRightPar = ch => ch == ')';
let isLeftSqu = ch => ch == '['; let isRightSqu = ch => ch == ']';
let isDigit = ch => /\d/.test(ch);
let isLetter = ch => /[a-z]|_/i.test(ch);
let is2Operator = ch => /<=|==|>=|&&|\|\||\*\*/.test(ch);
let isOperator = ch => /<|>|\+|-|\*|\/|\^/.test(ch);

const _var = "var"; let _isVar = (t,p) => t[p].type == _var;
const _num = "num"; let _isNum = (t,p) => t[p].type == _num;
const _fun = "fun"; let _isFun = (t,p) => t[p].type == _fun;
const _ope = "ope"; let _isOpe = (t,p) => t[p].type == _ope;
const _lpa = "lpa"; let _isLpa = (t,p) => t[p].type == _lpa;
const _rpa = "rpa"; let _isRpa = (t,p) => t[p].type == _rpa;
const _lsq = "lsq"; let _isLsq = (t,p) => t[p].type == _lsq;
const _rsq = "rsq"; let _isRsq = (t,p) => t[p].type == _rsq;
const _com = "com"; let _isCom = (t,p) => t[p].type == _com;

const substTablePrefix = [{from:'+', to:'pluspre'}, {from:'-', to:'minuspre'}];
const substTableInfix = [{from:'+', to:'plus'}, {from:'-', to:'minus'}, {from:'*', to:'times'}];

function tokenizer(str) {
	str.replace(/\s+/g, "");
	str = str.split("");
	let result = [];
	let stringBuffer = [];
	let numberBuffer = [];
  let nDots = 0;
  let i = 0;
	let char, char2;
  while(i < str.length) {
    char = str[i];
    if(isLetter(char)) {
      while(i < str.length && (isLetter(char) || isDigit(char))) {
        stringBuffer.push(char);
        char = str[++i];
      }
      if(isLeftPar(char)) result.push(new Token(_fun, stringBuffer.join('')));
      else result.push(new Token(_var, stringBuffer.join('')));
      stringBuffer = [];
			continue;
    }
		if(isDigit(char) || isDot(char)) {
      while(i < str.length && (isDigit(char) || isDot(char))) {
        numberBuffer.push(char);
        if(isDot(char)) nDots++;
        char = str[++i];
      }
      if(nDots < 2) result.push(new Token(_num, numberBuffer.join('')));
      else return "ERR: tokenizer-e1";
      numberBuffer = [];
      nDots = 0;
			continue;
		}
		if(i < str.length-1) {
			char2 = char + str[i+1];
			if(is2Operator(char2)) { result.push(new Token(_ope, char2)); i += 2; continue; }
		}
		if(isLeftPar(char)) { result.push(new Token(_lpa, char)); i++; continue; }
    if(isRightPar(char)) { result.push(new Token(_rpa, char)); i++; continue; }
		if(isLeftSqu(char)) { result.push(new Token(_lsq, char)); i++; continue; }
		if(isRightSqu(char)) { result.push(new Token(_rsq, char)); i++; continue; }
    if(isComma(char)) { result.push(new Token(_com, char)); i++; continue; }
		if(isOperator(char)) { result.push(new Token(_ope, char)); i++; continue; }
		return null;
  }
	return result;
}

let inRange = (tokens, pos) => (pos >= 0) && (pos < tokens.length);

function matchPar(t,p,d) { // vector of tokens, index of the parenthesis in the vector, direction of search (-1 or +1)
	let s1 = t[p].type; // start parenthesis
	let s2; // end parenthesis
	switch(t[p].type) {
		case _lpa: s2 = _rpa; break;
		case _rpa: s2 = _lpa; break;
		case _lsq: s2 = _rsq; break;
		case _rsq: s2 = _lsq; break;
		default: return null;
	}
	let n = 0; // number of nested parentheses
	let x;
	p += d;
	while(inRange(t,p)) {
		x = t[p].type;
		if(x == s2) {
			if(n == 0) return p; // found
			n--; // nested paired parenthesis: pop
		} else if(x == s1) n++; // nested same parenthesis: push
		p += d;
	}
	return null;
}

function getOperand(t,p,d) { // vector of tokens, index of operator in the vector, direction of search (-1 or +1)
	let c = p + d;
	if(!inRange(t,c)) return null;
	if(_isNum(t,c)) return [c,c]; // number operand
	if(_isVar(t,c)) {
		if(d < 0) return [c,c]; // (non-array) variable left operand
		if(!inRange(t,c+1) || !_isLsq(t,c+1)) return [c,c]; // (non-array) variable right operand
		if(_isLsq(t,c+1)) { // array variable right operand
			let r = matchPar(t,c+1,d);
			return r == null ? null : [c,r];
		}
	}
	if(_isLpa(t,c)) { // parenthesized right operand
		let r = matchPar(t,c,d);
		return r == null ? null : [c,r];
	}
	if(_isRpa(t,c)) { // parenthesized left operand or left function
		let l = matchPar(t,c,d);
		console.log([l,c]);
		return l == null ? null : [l,c];
	}
	return null;
}

function prefixOperator(t,p) { // vector of tokens, index of operator in the vector
	let rightOp = getOperand(t,p,1);
	if(rightOp == null) return null; // postfix operators not allowed
	let leftOp = getOperand(t,p,-1);
	if(leftOp == null) { // prefix operator: only need to make it a function
		t[p] = new Token(_fun, substTablePrefix.find(entry => entry.from == t[p].value).to);
		t.splice(rightOp[0], 0, new Token(_lpa, '('));
		t.splice(rightOp[1]+2, 0, new Token(_rpa, ')'));
		return;
	}
	t.splice(leftOp[0], 0, new Token(_fun, substTableInfix.find(entry => entry.from == t[p].value).to));
	t.splice(leftOp[0]+1, 0, new Token(_lpa, '('));
	t[leftOp[1]+3] = new Token(_com, ',');
	t.splice(rightOp[1]+5, 0, new Token(_rpa, ')'));
}


//let f = (x) => _max(1,2)+3;
let f = (x,y) => x*(1+2);
let fv = f.toString().split("=>");
let f0 = fv[0].trim();
let f1 = fv[1].trim();

document.write('<b>start></b> ' + f0 + ' => ' + f1 + '<br>');

let tokens = tokenizer(f1);
if(tokens == null) document.write("error in tokenization");
else {
  tokens.forEach((token, index) => document.write(index + "> " + token.type + ": " + token.value + "<br>"));

	/*
	prefixOperator(tokens, 0);
	f1 = '';
	tokens.forEach(token => f1 += token.value);
	document.write('<hr><b>transf></b> ' + f0 + ' => ' + f1 + '<br>');
	tokens.forEach((token, index) => document.write(index + "> " + token.type + ": " + token.value + "<br>"));
	*/
	prefixOperator(tokens, 4);
	prefixOperator(tokens, 1);
	f1 = '';
	tokens.forEach(token => f1 += token.value);
	document.write('<hr><b>transf></b> ' + f0 + ' => ' + f1 + '<br>');
	tokens.forEach((token, index) => document.write(index + "> " + token.type + ": " + token.value + "<br>"));



	//let ff = f0 + " => ";
  //tokens.forEach(token => ff += token.value);
  //f = eval(ff);
  //let x = 2;
  //document.write('<hr>' + ff + '<br>x = ' + x + '; f = ' + f(x));
}
</script>
</body>
</html>
